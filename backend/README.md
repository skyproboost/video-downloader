## Docker

Before running the project, copy .env file from example:

```bash
cp .env.example .env
```

And configure it at your ease.

Then you can start the project with docker using this command:

```bash
docker compose up --build
```

## Project structure

```bash
$ tree "app"
app
├── db  # module contains db configurations
│   ├── base.py  # base data for all models
│   ├── migrations  # migrations and migration scripts
│   ├── models  # db models
│   └── utils.py  # utils related to db
├── gunicorn_runner.py  # gunicorn class that wraps unicorn workers
├── __init__.py
├── log.py  # Logging configuration
├── __main__.py  # Startup script
├── pre_start.py  # Deploy script
├── services  # Package for different external services such as rabbitmq or redis etc
│   ├── __init__.py
│   └── redis
├── settings.py  # Main configuration settings for project.
├── utils  # modular structure of utils
│   └── common.py
└── web
    ├── api  # Rest api
    ├── application.py  # FastAPI application configuration.
    ├── __init__.py
    └── lifespan.py  # Contains actions to perform on startup and shutdown.
```

## Configuration

This application can be configured with environment variables.

You can create `.env` file in the root directory and place all
environment variables here. 

All environment variables should start with "app_" prefix.

For example if you see in your "app/settings.py" a variable named like
`random_parameter`, you should provide the "app_RANDOM_PARAMETER" 
variable to configure the value. This behavior can be changed by overriding `env_prefix` property
in `app.settings.Settings.Config`.

An example of .env file:
```bash
APP_RELOAD="True"
APP_PORT="8000"
APP_ENVIRONMENT="dev"
```

You can read more about BaseSettings class here: https://pydantic-docs.helpmanual.io/usage/settings/

## Pre-commit

To install pre-commit simply run inside the shell:
```bash
pre-commit install
```

pre-commit is very useful to check your code before publishing it.
It's configured using .pre-commit-config.yaml file.

By default it runs:
* ruff (spots possible bugs and formats the codebase);


You can read more about pre-commit here: https://pre-commit.com/

## Migrations

If you want to migrate your database, you should run following commands:
```bash
# To run all migrations until the migration with revision_id.
alembic upgrade "<revision_id>"

# To perform all pending migrations.
alembic upgrade "head"
```

### Reverting migrations

If you want to revert migrations, you should run:
```bash
# revert all migrations up to: revision_id.
alembic downgrade <revision_id>

# Revert everything.
alembic downgrade base
```

### Migration generation

To generate migrations you should run:
```bash
# For automatic change detection.
alembic revision --autogenerate -m "<message>"
```
Migrations will be timestamped and numerated.

## Dependencies

If you want to add new dependencies, run:

```bash
uv add <package>
```

If you want to add dev dependency (for instance mypy or ruff etc), run:

```bash
uv add --dev <package>
```

If you need to update dependencies, run:

```bash
uv sync
```

## Run locally

If you want to run project locally, just do:

```bash
uv run --frozen --no-dev alembic upgrade head
uv run --frozen --no-dev python -m app deploy
uv run --frozen --no-dev python -m app run
```

First 2 commands will prepare db and seed data, the third will run the app.

## Running tests

To run tests for your application, you can use the following command:

```bash
uv run --frozen pytest -vv .
```

> Tests are integrated into pre-commit as well.


## Kubernetes

To deploy app on kubernetes cluster, run the following commands:

```bash
./kdeploy.sh
```

> Autogenerated secrets will be printed out to the console.

Or if you want to deploy manually, you can do as follows:

1. Create namespaces:
```bash
cd kubernetes
kubectl apply -f base/namespaces.yaml
```

2. Create secrets:
```bash
kubectl create secret generic secrets \
                      --namespace prod \
                      --from-literal=APP_SECRET_KEY='secret' \
                      --from-literal=APP_ADMIN_PASSWORD='secret' \
                      --from-literal=APP_DB_PASS='secret' \
                      --from-literal=APP_DB_PROOT_PASS='secret' \
                      --from-literal=MINIO_ADMIN_PASSWORD='secret' 
kubectl create secret generic secrets \
                      --namespace stage \
                      --from-literal=APP_SECRET_KEY='secret' \
                      --from-literal=APP_ADMIN_PASSWORD='secret' \
                      --from-literal=APP_DB_PASS='secret' \
                      --from-literal=APP_DB_PROOT_PASS='secret' \
                      --from-literal=MINIO_ADMIN_PASSWORD='secret' 
```

3. Deploy environments:
```bash
kubectl apply -k overlays/prod
kubectl apply -k overlays/stage
```

